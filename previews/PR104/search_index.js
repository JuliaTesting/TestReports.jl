var documenterSearchIndex = {"docs":
[{"location":"library/#Library","page":"Library","title":"Library","text":"","category":"section"},{"location":"library/#Contents","page":"Library","title":"Contents","text":"","category":"section"},{"location":"library/","page":"Library","title":"Library","text":"Pages = [\"library.md\"]","category":"page"},{"location":"library/#Public","page":"Library","title":"Public","text":"","category":"section"},{"location":"library/","page":"Library","title":"Library","text":"Documentation for TestReports.jl's public interface.","category":"page"},{"location":"library/","page":"Library","title":"Library","text":"TestReports.test\nrecordproperty\nReportingTestSet\nany_problems\nreport","category":"page"},{"location":"library/#TestReports.test","page":"Library","title":"TestReports.test","text":"TestReports.test(; kwargs...)\nTestReports.test(pkg::Union{AbstractString, Vector{AbstractString}; kwargs...)\n\nKeyword arguments:\n\ncoverage::Bool=false: enable or disable generation of coverage statistics.\njulia_args::Union{Cmd, Vector{String}}: options to be passed to the test process.\ntest_args::Union{Cmd, Vector{String}}: test arguments (ARGS) available in the test process.\nlogfilepath::AbstractString=pwd(): file path where test reports are saved.\nlogfilename::Union{AbstractString, Vector{AbstractString}}: name(s) of test report file(s).\n\nGenerates a JUnit XML for the tests of package pkg, or for the current project (which thus needs to be a package) if no positional argument is given to TestReports.test. The test report is saved in the current working directory and called testlog.xml if both logfilepath and logfilename are not supplied. If pkg is of type Vector{String}, the report filenames are prepended with the package name, for example Example_testlog.xml.\n\nIf logfilename is supplied, it must match the type (and length, if a vector) of pkg.\n\nThe tests are run in the same way as Pkg.test.\n\n\n\n\n\n","category":"function"},{"location":"library/#TestReports.recordproperty","page":"Library","title":"TestReports.recordproperty","text":"recordproperty(name::String, value)\n\nAdds a property to a testset with name and value that will in turn be added to the <properties> node of the corresponding testsuite in the JUnit XML.\n\nMultiple properties can be added to one testset, but if the same property is set on both parent and child testsets, the value in the child testset takes precedence over that in the parent.\n\nThe suggested use of this function is to place it inside a testset with unspecified type (see Examples). This will ensure that Pkg.test is unnaffected, but that the properties are added to the report when TestReports.test is used. This is because properties are only added when the Testset type has a TestReports.properties method defined, as does the ReportingTestSet used by TestReports. TestReports.properties can be extended for custom TestSets.\n\nIf a child testset has this method defined but its parent doesn't, the property should be in the report when TestReport.test is used, assuming that the parent testset type doesn't do anything to affect the reporting behaviour. However this is not tested functionality.\n\nvalue must be serializable by EzML, which gives quite a lot of freedom.\n\nExamples\n\nusing TestReports\n\n# Default testset used, so function will not affect Pkg.test but will be used when\n# generating JUnit XML.\n@testset \"MyTestSet\" begin\n    recordproperty(\"ID\", 42)\n    recordproperty(\"File\", @__FILE__)\n    recordproperty(\"Bool\", true)\n    @test 1==1\n    @test 2==2\nend\n\nSee also: properties\n\n\n\n\n\n","category":"function"},{"location":"library/#TestReports.ReportingTestSet","page":"Library","title":"TestReports.ReportingTestSet","text":"ReportingTestSet\n\nCustom AbstractTestSet type designed to be used by TestReports.jl for creation of JUnit XMLs.\n\nDoes not throw an error when a test fails or has an error. Upon finishing, a ReportingTestSet will display the default test output, and then flatten to a structure that is suitable for report generation.\n\nIt is designed to be wrapped around a package's runtests.jl file and this is assumed when both the test results are displayed and when the TestSet is flatted upon finish. See bin/reporttests.jl for an example of this use. ReportingTestSets are not designed to be used directly in a package's tests, and this is not recommended or supported.\n\nA ReportingTestSet has the description and results fields as per a DefaultTestSet, and has the following additional fields:\n\nproperties: a dictionary which is used to record properties to be   inserted into the report.\nstart_time::DateTime: the start date and time of the testing (local system time).\ntime_taken::Millisecond: the time taken in milliseconds to run the TestSet.\nlast_record_time::DateTime: the time when record was last called.\nhostname::String: the name of host on which the testset was executed.\n\nSee also: flatten_results!, recordproperty, report\n\n\n\n\n\n","category":"type"},{"location":"library/#TestReports.any_problems","page":"Library","title":"TestReports.any_problems","text":"any_problems(ts)\n\nChecks a testset to see if there were any problems (Errors or Fails). Note that unlike the DefaultTestSet, the ReportingTestSet does not throw an exception on a failure. Thus to set the exit code from the runner code, we check it using exit(any_problems(top_level_testset)).\n\n\n\n\n\n","category":"function"},{"location":"library/#TestReports.report","page":"Library","title":"TestReports.report","text":"report(ts::AbstractTestSet) -> XMLDocument\n\nProduce an JUnit XML report details about the contained TestSets and Results. As the JUnit XML schema does not allow nested testsuite elements the report will flatten the hierarchical TestSet structure. Each TestSet will become a testsuite element and each Result will become a testcase element.\n\nA Result will only be reported once within its parent TestSet to avoid having duplicate entries within the report and avoid problems with total test counts not matching Julia output.\n\nAll AbstractTestSets contained within ts must have a description::AbstractString field and an iterable results field.\n\n\n\n\n\n","category":"function"},{"location":"library/#Private","page":"Library","title":"Private","text":"","category":"section"},{"location":"library/","page":"Library","title":"Library","text":"Package internals documentation.","category":"page"},{"location":"library/#Report-Generation","page":"Library","title":"Report Generation","text":"","category":"section"},{"location":"library/","page":"Library","title":"Library","text":"Modules = [TestReports]\nPages   = [\"runner.jl\"]\nPublic = false\nFilter = t -> t != TestReports.test","category":"page"},{"location":"library/#TestReports.TESTS_FAILED","page":"Library","title":"TestReports.TESTS_FAILED","text":"Exit code for runner when tests fail\n\n\n\n\n\n","category":"constant"},{"location":"library/#TestReports.checkexitcode!-NTuple{4, Any}","page":"Library","title":"TestReports.checkexitcode!","text":"checkexitcode!(errs, proc, pkg, logfilename)\n\nChecks proc.exitcode and acts as follows:\n\nIf 0, displays tests passed info message\nIf equal to TESTS_FAILED const, warning is displayed and pkg added to errs\nIf anything else, throws a PkgTestError\n\n\n\n\n\n","category":"method"},{"location":"library/#TestReports.gen_command-Tuple{Any, Any, Any}","page":"Library","title":"TestReports.gen_command","text":"gen_command(runner_code, julia_args, coverage)\n\nReturns Cmd which will run the runner code in a new Julia instance.\n\nSee also: gen_runner_code\n\n\n\n\n\n","category":"method"},{"location":"library/#TestReports.gen_runner_code-Tuple{Any, Any, Any}","page":"Library","title":"TestReports.gen_runner_code","text":"gen_runner_code(testfilename, logfilename, test_args)\n\nReturns runner code that will run the tests and generate the report in a new Julia instance.\n\n\n\n\n\n","category":"method"},{"location":"library/#TestReports.get_deps!-Tuple{Any, Any, Any}","page":"Library","title":"TestReports.get_deps!","text":"get_deps!(deps, manifest, pkg)\n\nPush dependencies for pkg found in manifest into deps.\n\n\n\n\n\n","category":"method"},{"location":"library/#TestReports.get_deps-Tuple{Any, Any}","page":"Library","title":"TestReports.get_deps","text":"get_deps(manifest, pkg) = get_deps!(String[], manifest, pkg)\n\nGet list of dependencies for pkg found in manifest\n\n\n\n\n\n","category":"method"},{"location":"library/#TestReports.get_manifest-Tuple{}","page":"Library","title":"TestReports.get_manifest","text":"get_manifest()\n\nReturn the parsed manifest that has TestReports as a dependency.\n\n\n\n\n\n","category":"method"},{"location":"library/#TestReports.get_testreports_environment-Tuple{}","page":"Library","title":"TestReports.get_testreports_environment","text":"get_testreports_environment()\n\nReturns new environment to be pushed to LOAD_PATH to ensure TestReports, Test and their dependencies are available for report generation.\n\n\n\n\n\n","category":"method"},{"location":"library/#TestReports.gettestfilepath-Tuple{Pkg.Types.Context, Pkg.Types.PackageSpec}","page":"Library","title":"TestReports.gettestfilepath","text":"gettestfilepath(ctx::Context, pkgspec::Pkg.Types.PackageSpec)\n\nGets the testfile path of the package. Code for each Julia version mirrors that found  in Pkg/src/Operations.jl.\n\n\n\n\n\n","category":"method"},{"location":"library/#TestReports.isinstalled!-Tuple{Pkg.Types.Context, Pkg.Types.PackageSpec}","page":"Library","title":"TestReports.isinstalled!","text":"isinstalled!(ctx::Context, pkgspec::Pkg.Types.PackageSpec)\n\nChecks if the package is installed by using ensure_resolved from Pkg/src/Types.jl. This function fails if the package is not installed, but here we wrap it in a try-catch as we may want to test another package after the one that isn't installed.\n\nFor Julia versions V1.4 and later, the first arguments of the Pkg functions used is of type Pkg.Types.Context. For earlier versions, they are of type Pkg.Types.EnvCache.\n\n\n\n\n\n","category":"method"},{"location":"library/#TestReports.make_testreports_environment-Tuple{Any}","page":"Library","title":"TestReports.make_testreports_environment","text":"make_testreports_environment(manifest)\n\nMake a new environment in a temporary directory, using information from the parsed manifest provided.\n\n\n\n\n\n","category":"method"},{"location":"library/#TestReports.runtests!-Tuple{Vector, Any, Any, Any}","page":"Library","title":"TestReports.runtests!","text":"runtests!(errs::Vector, pkg, cmd, logfilename)\n\nRuns cmd which will run the tests of pkg. The exit code of the process is then checked.\n\n\n\n\n\n","category":"method"},{"location":"library/#TestReports.test!-Tuple{AbstractString, Vector{AbstractString}, Vector{AbstractString}, Vector{AbstractString}, AbstractString}","page":"Library","title":"TestReports.test!","text":"test!(pkg::AbstractString,\n      errs::Vector{AbstractString},\n      nopkgs::Vector{AbstractString},\n      notests::Vector{AbstractString},\n      logfilename::AbstractString;\n      coverage::Bool=false,\n      julia_args::Union{Cmd, AbstractVector{<:AbstractString}}=``,\n      test_args::Union{Cmd, AbstractVector{<:AbstractString}}=``)\n\nTests pkg and save report to logfilename. Tests are run in the same way as Pkg.test.\n\nIf tests error pkg is added to nopkgs. If pkg has no testfile it is added to notests. If pkg is not installed it is added to nopkgs.\n\n\n\n\n\n","category":"method"},{"location":"library/#TestSets","page":"Library","title":"TestSets","text":"","category":"section"},{"location":"library/","page":"Library","title":"Library","text":"Modules = [TestReports]\nPages   = [\"testsets.jl\"]\nPublic = false","category":"page"},{"location":"library/#TestReports.ReportingResult","page":"Library","title":"TestReports.ReportingResult","text":"ReportingResult{T}\n\nWraps a Result of type T so that additional metadata can be saved.\n\nfields\n\nresult::T: Result that is being wrapped.\ntime_taken::Millisecond: the time taken (milliseconds) for this test to be run.\n\n\n\n\n\n","category":"type"},{"location":"library/#TestReports._flatten_results!-Tuple{Test.AbstractTestSet, Int64}","page":"Library","title":"TestReports._flatten_results!","text":"_flatten_results!(ts::AbstractTestSet)::Vector{<:AbstractTestSet}\n\nRecursively flatten ts to a vector of TestSets.\n\n\n\n\n\n","category":"method"},{"location":"library/#TestReports._flatten_results!-Tuple{Test.Result, Int64}","page":"Library","title":"TestReports._flatten_results!","text":"_flatten_results!(rs::Result)\n\nReturn vector containing rs so that when iterated through, rs is added to the results vector.\n\n\n\n\n\n","category":"method"},{"location":"library/#TestReports.add_to_ts_default!-Tuple{Test.DefaultTestSet, TestReports.ReportingResult}","page":"Library","title":"TestReports.add_to_ts_default!","text":"add_to_ts_default!(ts_default::DefaultTestSet, result::Result)\nadd_to_ts_default!(ts_default::DefaultTestSet, result::ReportingResult)\nadd_to_ts_default!(ts_default::DefaultTestSet, ts::AbstractTestSet)\nadd_to_ts_default!(ts_default::DefaultTestSet, ts::ReportingTestSet)\n\nPopulate ts_default with the supplied variable. If result is a Result or an AbstractTestSet (but not a ReportingTestSet) then it is recorded. If it is a ReportingTestSet then a new DefaultTestSet with matching description is created, populated by recursively calling this function and then added to the results of ts_default. If result is a ReportingResult, the Result contained by the ReportingResult is added to ts_default.\n\n\n\n\n\n","category":"method"},{"location":"library/#TestReports.display_reporting_testset-Tuple{ReportingTestSet}","page":"Library","title":"TestReports.display_reporting_testset","text":"display_reporting_testset(ts::ReportingTestSet)\n\nDisplays the test output in the same format as Pkg.test by using a DefaultTestSet.\n\n\n\n\n\n","category":"method"},{"location":"library/#TestReports.flatten_results!-Tuple{Test.AbstractTestSet}","page":"Library","title":"TestReports.flatten_results!","text":"flatten_results!(ts::AbstractTestSet)\n\nReturns a flat vector of TestSets which only contain Results. This is necessary for writing a JUnit XML report the schema does not allow nested XML testsuite elements.\n\n\n\n\n\n","category":"method"},{"location":"library/#TestReports.has_description-Tuple{Test.AbstractTestSet}","page":"Library","title":"TestReports.has_description","text":"has_description(ts::AbstractTestSet) -> Bool\n\nDetermine if the testset has been provided a description.\n\n\n\n\n\n","category":"method"},{"location":"library/#TestReports.hostname-Tuple{ReportingTestSet}","page":"Library","title":"TestReports.hostname","text":"hostname(ts::ReportingTestSet)\nhostname(ts::AbstractTestSet)\n\nGet the hostname of a ReportingTestSet, returns gethostname() for an AbstractTestSet. Can be extended for custom TestSets, must return a string.\n\n\n\n\n\n","category":"method"},{"location":"library/#TestReports.ispass-Tuple{Test.Pass}","page":"Library","title":"TestReports.ispass","text":"ispass(result)\n\nReturn true if result is a Pass or a ReportingResult{Pass}, otherwise return false.\n\n\n\n\n\n","category":"method"},{"location":"library/#TestReports.properties-Tuple{ReportingTestSet}","page":"Library","title":"TestReports.properties","text":"properties(ts::ReportingTestSet)\nproperties(ts::AbstractTestSet)\n\nGet the properties dictionary of a ReportingTestSet, returns nothing for an AbstractTestSet. Can be extended for custom TestSets, and must return either a Dict or nothing.\n\n\n\n\n\n","category":"method"},{"location":"library/#TestReports.set_start_time!-Tuple{ReportingTestSet, Dates.DateTime}","page":"Library","title":"TestReports.set_start_time!","text":"set_start_time!(ts::ReportingTestSet, start_time)\nset_start_time!(ts::AbstractTestSet, start_time)\n\nSets the start time field of a ReportingTestSet. This is used when flattening ReportingTestSets for report generation and an be extended for custom TestSets.\n\n\n\n\n\n","category":"method"},{"location":"library/#TestReports.set_time_taken!-Tuple{ReportingTestSet, Dates.Millisecond}","page":"Library","title":"TestReports.set_time_taken!","text":"set_time_taken!(ts::ReportingTestSet, time_taken)\nset_time_taken!(ts::AbstractTestSet, time_taken)\n\nSets the time taken field of a ReportingTestSet. This is used when flattening ReportingTestSets for report generation and an be extended for custom TestSets.\n\n\n\n\n\n","category":"method"},{"location":"library/#TestReports.start_time-Tuple{ReportingTestSet}","page":"Library","title":"TestReports.start_time","text":"start_time(ts::ReportingTestSet)\nstart_time(ts::AbstractTestSet)\n\nGet the start time of a ReportingTestSet, returns Dates.now() for an AbstractTestSet. Can be extended for custom TestSets, must return a DateTime.\n\n\n\n\n\n","category":"method"},{"location":"library/#TestReports.time_taken-Tuple{ReportingTestSet}","page":"Library","title":"TestReports.time_taken","text":"time_taken(ts::ReportingTestSet)\ntime_taken(ts::AbstractTestSet)\n\nGet the time taken of a ReportingTestSet, returns Dates.Millisecond(0) for an AbstractTestSet. Can be extended for custom TestSets, must return a Dates.Millisecond.\n\n\n\n\n\n","category":"method"},{"location":"library/#TestReports.time_taken-Tuple{TestReports.ReportingResult}","page":"Library","title":"TestReports.time_taken","text":"time_taken(result::ReportingResult)\ntime_taken(result::Result)\n\nFor a ReportingResult, return the time taken for the test to run. For a Result, return Dates.Millisecond(0).\n\n\n\n\n\n","category":"method"},{"location":"library/#TestReports.update_testset_properties!-Tuple{Test.AbstractTestSet, Test.AbstractTestSet}","page":"Library","title":"TestReports.update_testset_properties!","text":"update_testset_properties!(childts::AbstractTestSet, ts::AbstractTestSet)\n\nAdds properties of ts to childts. If any properties being added already exist in childts, a warning is displayed and the value in ts is overwritten.\n\nIf the types of ts and\\or childts do not a method defined for TestReports.properties, this is handled as follows:\n\nIf method not defined for typeof(ts), it has no properties to add to childts   and therefore nothing happens.\nIf method not defined for typeof(chidlts) and ts has properties, then a warning   is shown.\n\nSee also: properties\n\n\n\n\n\n","category":"method"},{"location":"library/#XML-Writing","page":"Library","title":"XML Writing","text":"","category":"section"},{"location":"library/","page":"Library","title":"Library","text":"Modules = [TestReports]\nPages   = [\"to_xml.jl\"]\nPublic = false","category":"page"},{"location":"library/#TestReports.add_testsuite_properties!-Tuple{Any, Test.AbstractTestSet}","page":"Library","title":"TestReports.add_testsuite_properties!","text":"add_testsuite_properties!(x_testsuite, ts::AbstractTestSet)\n\nAdd all key value pairs in the properties field of a AbstractTestSet to the corresponding testsuite xml element. This function assumes that the type of ts has a TestReports.properties method defined.\n\nSee also: properties\n\n\n\n\n\n","category":"method"},{"location":"library/#TestReports.check_ts-Tuple{Vector{<:Test.AbstractTestSet}}","page":"Library","title":"TestReports.check_ts","text":"check_ts(ts::AbstractTestSet)\n\nThrows an exception if ts does not have the right structure for report or if the results of ts do not have both description or results fields.\n\nSee also: report\n\n\n\n\n\n","category":"method"},{"location":"library/#TestReports.error_xml-Tuple{Any, Any, Any}","page":"Library","title":"TestReports.error_xml","text":"failure_xml(message, test_type, content)\n\nCreate an error node (which will be the child of a testcase).\n\n\n\n\n\n","category":"method"},{"location":"library/#TestReports.failure_xml-Tuple{Any, Any, Any}","page":"Library","title":"TestReports.failure_xml","text":"failure_xml(message, test_type, content)\n\nCreate a failure node (which will be the child of a testcase).\n\n\n\n\n\n","category":"method"},{"location":"library/#TestReports.format_period_for_xml-Tuple{Dates.Millisecond}","page":"Library","title":"TestReports.format_period_for_xml","text":"formatperiodfor_xml(time::Millisecond)\n\nFormats a millisecond value into a string in seconds with 3 decimal places.\n\n@sprintf is used to ensure that value does not use scientific notification, which is not allowed in an XML decimal.\n\nMethods for other Periods have not been written as are not currently required.\n\n\n\n\n\n","category":"method"},{"location":"library/#TestReports.get_error_info-Tuple{Test.Error}","page":"Library","title":"TestReports.get_error_info","text":"get_error_info(v::Error)\n\nReturn message and type of error for testcase attribute, and number of tests (either 1 or 0). Uses test_type field to determine what caused the original error.\n\n\n\n\n\n","category":"method"},{"location":"library/#TestReports.get_failure_message-Tuple{Test.Fail}","page":"Library","title":"TestReports.get_failure_message","text":"getfailuremessage(v::Fail)\n\nReturn message for failed test testcase attribute. Uses test_type field to determine what caused the original failure.\n\n\n\n\n\n","category":"method"},{"location":"library/#TestReports.set_attribute!-Tuple{Any, Any, Any}","page":"Library","title":"TestReports.set_attribute!","text":"set_attribute!(node, attr, val)\nset_attribute!(node, attr, val::Period)\n\nAdd the attritube with name attr and value val to node.\n\nIf val is of type Period, format with format_period_for_xml.\n\n\n\n\n\n","category":"method"},{"location":"library/#TestReports.skip_xml-Tuple{}","page":"Library","title":"TestReports.skip_xml","text":"skip_xml()\n\nCreate a skip node (which will be the child of a testcase).\n\n\n\n\n\n","category":"method"},{"location":"library/#TestReports.testcase_xml-Tuple{Any, Any, Any}","page":"Library","title":"TestReports.testcase_xml","text":"testcase_xml(name, id, x_children)\n\nCreate a testcase element of a JUnit XML.\n\nThis is the generic form (with name, id and children) that is used by other methods.\n\n\n\n\n\n","category":"method"},{"location":"library/#TestReports.testcase_xml-Tuple{Test.Result, Any}","page":"Library","title":"TestReports.testcase_xml","text":"testcase_xml(v::Result, childs)\n\nCreate a testcase element of a JUnit XML for the result v.\n\nThe original expression of the test is used as the name, whilst the id is defaulted to testcaseid_.\n\n\n\n\n\n","category":"method"},{"location":"library/#TestReports.testsuite_xml-NTuple{8, Any}","page":"Library","title":"TestReports.testsuite_xml","text":"testsuite_xml(name, ntests, nfails, nerrors, x_children)\n\nCreate a testsuite element of a JUnit XML.\n\n\n\n\n\n","category":"method"},{"location":"library/#TestReports.testsuites_xml-NTuple{4, Any}","page":"Library","title":"TestReports.testsuites_xml","text":"testsuites_xml(ntests, nfails, nerrors, x_children)\n\nCreate the testsuites element of a JUnit XML.\n\n\n\n\n\n","category":"method"},{"location":"library/#TestReports.to_xml-Tuple{Test.AbstractTestSet}","page":"Library","title":"TestReports.to_xml","text":"to_xml(ts::AbstractTestSet)\n\nCreate a testsuite node from a AbstractTestSet, by creating nodes for each result in ts.results. For creating a JUnit XML, all results must be AbstractResults, that is they cannot be AbstractTestSets, as the XML cannot have one testsuite nested inside another.\n\n\n\n\n\n","category":"method"},{"location":"library/#TestReports.to_xml-Tuple{Test.Pass}","page":"Library","title":"TestReports.to_xml","text":"to_xml(res::Pass)\nto_xml(res::Fail)\nto_xml(res::Broken)\nto_xml(res::Error)\nto_xml(res::ReportingResult)\n\nCreate a testcase node from the result and return it along with information on number of tests.\n\n\n\n\n\n","category":"method"},{"location":"library/#Index","page":"Library","title":"Index","text":"","category":"section"},{"location":"library/","page":"Library","title":"Library","text":"Pages = [\"library.md\"]","category":"page"},{"location":"contributing/#Contributing","page":"Contributing","title":"Contributing","text":"","category":"section"},{"location":"contributing/","page":"Contributing","title":"Contributing","text":"`TestReports.jl follows the ColPrac guide for collaborative practices. New contributors should make sure to read that guide","category":"page"},{"location":"manual/#Manual","page":"Manual","title":"Manual","text":"","category":"section"},{"location":"manual/#Contents","page":"Manual","title":"Contents","text":"","category":"section"},{"location":"manual/","page":"Manual","title":"Manual","text":"Pages = [\"manual.md\"]\nDepth = 2","category":"page"},{"location":"manual/#Testing-Packages","page":"Manual","title":"Testing Packages","text":"","category":"section"},{"location":"manual/","page":"Manual","title":"Manual","text":"TestReports.jl provides two methods to test and generate JUnit XMLs for a package. The suggested approach is to use TestReports.test, but additionaly a runner script is also supplied.","category":"page"},{"location":"manual/","page":"Manual","title":"Manual","text":"TestReports.test can be used in the same way as Pkg.test. It will run the package unit tests, and, by default, create a testlog.xml file in the current directory:","category":"page"},{"location":"manual/","page":"Manual","title":"Manual","text":"julia> TestReports.test(\"MyPackage\")","category":"page"},{"location":"manual/","page":"Manual","title":"Manual","text":"info: Do I need to change `runtests.jl`?\nIt is intended that it runtests.jl will not need to be changed to generate a report (unless properties are being added).This does assume, however, that no custom TestSets are being used. In the case of custom TestSets, please see the discussion below.","category":"page"},{"location":"manual/","page":"Manual","title":"Manual","text":"The typical use in a CI process would be:","category":"page"},{"location":"manual/","page":"Manual","title":"Manual","text":"$ julia -e 'using Pkg; Pkg.add(\"TestReports\"); using TestReports; TestReports.test(\"MyPackage\")'","category":"page"},{"location":"manual/","page":"Manual","title":"Manual","text":"It is possible for multiple packages to be tested at once (with one report generated per package), or for the current project to be tested:","category":"page"},{"location":"manual/","page":"Manual","title":"Manual","text":"julia> TestReports.test([\"MyPackage1\", \"MyPackage2\"])  # Multiple packages\njulia> TestReports.test()  # Current project","category":"page"},{"location":"manual/","page":"Manual","title":"Manual","text":"TestReports.test will display the same output as Pkg.test, and accepts the same keyword arguments, namely:","category":"page"},{"location":"manual/","page":"Manual","title":"Manual","text":"coverage -  enable or disable generation of coverage statistics.\njulia_args - options to be passed to the test process.\ntest_args - test arguments (ARGS) available in the test process.","category":"page"},{"location":"manual/","page":"Manual","title":"Manual","text":"and has two additional keyword arguments to control the name and location of the report(s):","category":"page"},{"location":"manual/","page":"Manual","title":"Manual","text":"logfilepath - directory in which test reports are saved.\nlogfilename - name(s) of test report file(s).","category":"page"},{"location":"manual/#Customising-Testfile-Name-and-Location","page":"Manual","title":"Customising Testfile Name and Location","text":"","category":"section"},{"location":"manual/","page":"Manual","title":"Manual","text":"When testing a single package, the testfile name defaults to testlog.xml and is saved in the current working directory. The keyword arguments logfilepath and logfilename can be used to modify the name and/or path of the testfile, for example:","category":"page"},{"location":"manual/","page":"Manual","title":"Manual","text":"julia> TestReports.test(\"MyPackage\", logfilename=\"MyPackage.xml\")\n# File path is joinpath(pwd(), \"MyPackage.xml\")\njulia> TestReports.test(\"MyPackage\", logfilepath=\"path\")\n# File path is joinpath(\"path\", \"testlog.xml\")\njulia> TestReports.test(\"MyPackage\", logfilename=\"MyPackage.xml\", logfilepath=\"path\")\n# File path is joinpath(\"path\", \"MyPackage.xml\")","category":"page"},{"location":"manual/","page":"Manual","title":"Manual","text":"When testing multiple packages, the testfiles default to being called PackageName_testlog.xml for each package. The keyword arguments can again be used to customise this, for example:","category":"page"},{"location":"manual/","page":"Manual","title":"Manual","text":"julia> TestReports.test([\"MyPackage1\", \"MyPackage2\"], logfilename=[\"1.xml\", \"2.xml\"])\n# File paths are joinpath(pwd(), \"1.xml\") and joinpath(pwd(), \"2.xml\")\njulia> TestReports.test([\"MyPackage1\", \"MyPackage2\"], logfilename=[\"1.xml\", \"2.xml\"], logfilepath=\"path\")\n# File paths are joinpath(\"path\", \"1.xml\") and joinpath(\"path\", \"2.xml\")","category":"page"},{"location":"manual/#Adding-Properties","page":"Manual","title":"Adding Properties","text":"","category":"section"},{"location":"manual/","page":"Manual","title":"Manual","text":"Properties can be added to a TestSet using the exported function recordproperty within runtests.jl and other included scripts:","category":"page"},{"location":"manual/","page":"Manual","title":"Manual","text":"using Test\nusing TestReports\n\n@testset \"MyTests\" begin\n    recordproperty(\"ID\", 1)\n    @test 1==1\nend","category":"page"},{"location":"manual/","page":"Manual","title":"Manual","text":"recordproperty will have no affect during normal unit testing.","category":"page"},{"location":"manual/","page":"Manual","title":"Manual","text":"The added properties will be added to the corresponding testsuite in the generated report. Multiple properties can be added, and a property added to a parent TestSet will be applied to all child TestSets.","category":"page"},{"location":"manual/","page":"Manual","title":"Manual","text":"An error will be thrown if the same property is set twice in a TestSet, and a warning displayed if both parent and child TestSet have the same property set (in which case the value set in the child will take be used in the report).","category":"page"},{"location":"manual/","page":"Manual","title":"Manual","text":"The property name must always be a String, but the value can be anything that is serializable by EzXML.jl. In practice this means that Strings, Numbers, Exprs and Symbols can be used, as well as other types.","category":"page"},{"location":"manual/","page":"Manual","title":"Manual","text":"This example shows a more complete example:","category":"page"},{"location":"manual/","page":"Manual","title":"Manual","text":"using Test\nusing TestReports\n\n@testset \"TopLevelTests\" begin\n    recordproperty(\"TestFile\" @__FILE__)  # This will be added to all child testsets in report\n\n    @testset \"MiddleLevelTests\" begin\n        recordproperty(\"Testsuite\", 100)\n        recordproperty(\"TestSubject\", \"Example\")\n\n        @testset \"Inner\" begin\n            recordproperty(\"Testsuite\", 101)  # This will overwrite parent testset value\n            @test 1==1\n        end\n\n        @testset \"Types\" begin\n            recordproperty(\"Prop1\", :Val1)\n            @test 1==1\n        end\n    end\nend","category":"page"},{"location":"manual/#Runner-Script","page":"Manual","title":"Runner Script","text":"","category":"section"},{"location":"manual/","page":"Manual","title":"Manual","text":"Alternatively to TestReports.test, bin/reporttests.jl is a script that runs tests and reports the results. Use it via:","category":"page"},{"location":"manual/","page":"Manual","title":"Manual","text":"$ julia bin/reporttests.jl tests/runtests.jl","category":"page"},{"location":"manual/","page":"Manual","title":"Manual","text":"Replacing tests/runtests.jl with the path to the package test file. This script creates a file testlog.xml in the current directory.","category":"page"},{"location":"manual/#Known-Limitations","page":"Manual","title":"Known Limitations","text":"","category":"section"},{"location":"manual/#Single-Nesting","page":"Manual","title":"Single Nesting","text":"","category":"section"},{"location":"manual/","page":"Manual","title":"Manual","text":"Julia TestSets can be nested to an arbitary degree, but this is not allowed by the JUnit XML schema. Therefore, nested TestSets are flatted in the report.","category":"page"},{"location":"manual/","page":"Manual","title":"Manual","text":"For example, the following runtests.jl file:","category":"page"},{"location":"manual/","page":"Manual","title":"Manual","text":"using Test\n\n@testset \"TopLevel\" begin\n    @testset \"Middle1\" begin\n        @test 1==1\n        @test 2==2\n    end\n    @testset \"Middle2\" begin\n        @testset \"Inner1\" begin\n            @test 1==1\n        end\n    end\n    @test 1==1\nend","category":"page"},{"location":"manual/","page":"Manual","title":"Manual","text":"Will generate the following XML (when pretty printed):","category":"page"},{"location":"manual/","page":"Manual","title":"Manual","text":"<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n<testsuites tests=\"4\" failures=\"0\" errors=\"0\">\n    <testsuite name=\"TopLevel/Middle1\" tests=\"2\" failures=\"0\" errors=\"0\" time=\"0.156\" timestamp=\"2022-03-30T07:55:12.173\" hostname=\"hostname\" id=\"0\">\n        <testcase name=\"1 == 1\" id=\"1\" classname=\"TopLevel/Middle1\" time=\"0.028\"/>\n        <testcase name=\"2 == 2\" id=\"2\" classname=\"TopLevel/Middle1\" time=\"0.000\"/>\n    </testsuite>\n    <testsuite name=\"TopLevel/Middle2/Inner1\" tests=\"1\" failures=\"0\" errors=\"0\" time=\"0.000\" timestamp=\"2022-03-30T07:55:12.329\" hostname=\"hostname\" id=\"1\">\n        <testcase name=\"1 == 1\" id=\"1\" classname=\"TopLevel/Middle2/Inner1\" time=\"0.000\"/>\n    </testsuite>\n    <testsuite name=\"TopLevel\" tests=\"1\" failures=\"0\" errors=\"0\" time=\"0.156\" timestamp=\"2022-03-30T07:55:12.173\" hostname=\"hostname\" id=\"2\">\n        <testcase name=\"1 == 1\" id=\"1\" classname=\"TopLevel\" time=\"0.000\"/>\n    </testsuite>\n</testsuites>","category":"page"},{"location":"manual/","page":"Manual","title":"Manual","text":"Each test is recorded in a separate testsuite with the name showing the original nesting.","category":"page"},{"location":"manual/#Custom-TestSet-Types","page":"Manual","title":"Custom TestSet Types","text":"","category":"section"},{"location":"manual/","page":"Manual","title":"Manual","text":"TestReports.jl has not been tested significantly with custom TestSet types, please raise an issue if you find any problems/have a request.","category":"page"},{"location":"manual/","page":"Manual","title":"Manual","text":"However at a minimum, for a custom TestSet type to work with TestReports it must:","category":"page"},{"location":"manual/","page":"Manual","title":"Manual","text":"Push itself onto its parent when finishing, if it is not at the top level\nHave description and results fields as per a DefaultTestSet","category":"page"},{"location":"manual/","page":"Manual","title":"Manual","text":"The following information in a JUnit XML relies on the functionality of ReportingTestSets but can be added to your own custom TestSet as described in the table.","category":"page"},{"location":"manual/","page":"Manual","title":"Manual","text":"Information Description\ntestcase time This is extracted from a ReportingResult by the TestReports.time_taken function. For standard Results, rather than ReportingResults, this function returns Dates.Millisecond(0). This function can be extended for other custom Result types.\ntestsuite time This is extracted from a TestSet by the TestReports.time_taken function, which can be extended for custom TestSets. If not extended, the AbstractTestSet method will be used and the value defaults to Dates.Millisecond(0).\ntestsuite timestamp This is extracted from a TestSet by the TestReports.start_time function, which can be extended for custom TestSets. If not extended, the AbstractTestSet method will be used and the value defaults to Dates.now().\ntestsuite hostname This is extracted from a TestSet by the TestReports.hostname function, which can be extended for custom TestSets. If not extended, the AbstractTestSet method will be used and the value defaults to gethostname().\ntestsuite properties This is extracted from a TestSet by the TestReports.properties function, which can be extended for custom TestSets. If not extended, the AbstractTestSet method will be used and the value defaults to nothing.","category":"page"},{"location":"manual/","page":"Manual","title":"Manual","text":"For further details on extending these fuctions, see the docstrings in TestSets.","category":"page"},{"location":"manual/","page":"Manual","title":"Manual","text":"The source code of TestReports can be used as a starting point for including this behaviour in your custom TestSets.","category":"page"},{"location":"manual/","page":"Manual","title":"Manual","text":"If no TestSet types are specified (as per the standard Test approach), TestSet functionality will ensure that all child TestSets inherit the ReportingTestSet type.","category":"page"},{"location":"#TestReports.jl","page":"Home","title":"TestReports.jl","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"A JUnit XML test report generator for Julia","category":"page"},{"location":"","page":"Home","title":"Home","text":"This package produces JUnit XML test reports. It is for use with your CI tooling of choice, for example a CI tool like GoCD consumes reports in this format and gives back HTML reports.","category":"page"},{"location":"#Getting-Started","page":"Home","title":"Getting Started","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"The reporting is designed to enable you to write your unit tests in the standard Julia way, that is using test/runtests.jl as the entry point to your tests and with default TestSet types. In theory, it should also work with custom TestSet types - see the Manual for  further information.","category":"page"},{"location":"","page":"Home","title":"Home","text":"To test and generate a report for your package:","category":"page"},{"location":"","page":"Home","title":"Home","text":"julia> TestReports.test(\"MyPackage\")\n# Unit tests run, report saved to testlog.xml in current working directory","category":"page"},{"location":"","page":"Home","title":"Home","text":"To add to CI:","category":"page"},{"location":"","page":"Home","title":"Home","text":"$ julia -e 'using Pkg; Pkg.add(\"TestReports\"); using TestReports; TestReports.test(\"MyPackage\")'","category":"page"},{"location":"","page":"Home","title":"Home","text":"Additionally, properties can be added to your TestSets. To do this, use the recordproperty function like so:","category":"page"},{"location":"","page":"Home","title":"Home","text":"using Test\nusing TestReports\n\n@testset \"MyTests\" begin\n    recordproperty(\"ID\", 1)\n    @test 1==1\nend","category":"page"},{"location":"#The-JUnit-XML-Schema","page":"Home","title":"The JUnit XML Schema","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"The JUnit XML schema is a format used by many CI tools. For a definition of the schema, see here.","category":"page"},{"location":"","page":"Home","title":"Home","text":"For reports generated by TestReports.jl, the timestamp attribute of testsuite elements will be in the local system timezone.","category":"page"},{"location":"#Example-of-Use","page":"Home","title":"Example of Use","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Below is a screen shot of TestReports being used with GoCD, to report an test failure in DataDepsGenerators.jl.","category":"page"},{"location":"","page":"Home","title":"Home","text":"(Image: Screenshot of GoCD web-interface showing failing tests)","category":"page"},{"location":"","page":"Home","title":"Home","text":"The corresponding testlog.xml file (produced with an earlier version of TestReports, and therefore missing some of the new features, and after pretty printing) is below.","category":"page"},{"location":"","page":"Home","title":"Home","text":"<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n<testsuites name=\"/UCI\" id=\"now\" tests=\"7\" failures=\"1\" errors=\"0\">\n  <testsuite name=\"\" id=\"_id_\" tests=\"1\" failures=\"0\" errors=\"0\">\n    <testcase name=\"pass (info lost)\" id=\"_testcase_id_\"/>\n  </testsuite>\n  <testsuite name=\"\" id=\"_id_\" tests=\"1\" failures=\"0\" errors=\"0\">\n    <testcase name=\"pass (info lost)\" id=\"_testcase_id_\"/>\n  </testsuite>\n  <testsuite name=\"\" id=\"_id_\" tests=\"1\" failures=\"0\" errors=\"0\">\n    <testcase name=\"pass (info lost)\" id=\"_testcase_id_\"/>\n  </testsuite>\n  <testsuite name=\"\" id=\"_id_\" tests=\"1\" failures=\"0\" errors=\"0\">\n    <testcase name=\"pass (info lost)\" id=\"_testcase_id_\"/>\n  </testsuite>\n  <testsuite name=\"\" id=\"_id_\" tests=\"1\" failures=\"0\" errors=\"0\">\n    <testcase name=\"pass (info lost)\" id=\"_testcase_id_\"/>\n  </testsuite>\n  <testsuite name=\"ForestFires\" id=\"_id_\" tests=\"2\" failures=\"1\" errors=\"0\">\n    <testcase name=\"contains(registration_block, &quot;A Data Mining Approach to Predict Forest Fires using Meteorological Data&quot;)\" id=\"_testcase_id_\">\n      <failure message=\"nothing\" type=\"test\">Test Failed\n  Expression: contains(registration_block, \"A Data Mining Approach to Predict Forest Fires using Meteorological Data\")</failure>\n    </testcase>\n    <testcase name=\"pass (info lost)\" id=\"_testcase_id_\"/>\n  </testsuite>\n</testsuites>","category":"page"}]
}
