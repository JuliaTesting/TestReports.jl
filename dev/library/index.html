<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Library · TestReports.jl</title><link rel="canonical" href="https://juliatesting.github.io/TestReports.jl/stable/library/"/><link href="https://fonts.googleapis.com/css?family=Lato|Roboto+Mono" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.11.2/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.11.2/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.11.2/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.11.1/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL=".."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../assets/documenter.js"></script><script src="../siteinfo.js"></script><script src="../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-dark.css" data-theme-name="documenter-dark"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../assets/themeswap.js"></script></head><body><div id="documenter"><nav class="docs-sidebar"><a class="docs-logo" href="../"><img src="../assets/logo.png" alt="TestReports.jl logo"/></a><div class="docs-package-name"><span class="docs-autofit">TestReports.jl</span></div><form class="docs-search" action="../search/"><input class="docs-search-query" id="documenter-search-query" name="q" type="text" placeholder="Search docs"/></form><ul class="docs-menu"><li><a class="tocitem" href="../">Home</a></li><li><a class="tocitem" href="../manual/">Manual</a></li><li class="is-active"><a class="tocitem" href>Library</a><ul class="internal"><li><a class="tocitem" href="#Contents"><span>Contents</span></a></li><li><a class="tocitem" href="#Public"><span>Public</span></a></li><li><a class="tocitem" href="#Private"><span>Private</span></a></li><li><a class="tocitem" href="#Index"><span>Index</span></a></li></ul></li><li><a class="tocitem" href="../contributing/">Contributing</a></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><nav class="breadcrumb"><ul class="is-hidden-mobile"><li class="is-active"><a href>Library</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>Library</a></li></ul></nav><div class="docs-right"><a class="docs-edit-link" href="https://github.com/JuliaTesting/TestReports.jl/blob/master/docs/src/library.md" title="Edit on GitHub"><span class="docs-icon fab"></span><span class="docs-label is-hidden-touch">Edit on GitHub</span></a><a class="docs-settings-button fas fa-cog" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-sidebar-button fa fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a></div></header><article class="content" id="documenter-page"><h1 id="Library"><a class="docs-heading-anchor" href="#Library">Library</a><a id="Library-1"></a><a class="docs-heading-anchor-permalink" href="#Library" title="Permalink"></a></h1><h2 id="Contents"><a class="docs-heading-anchor" href="#Contents">Contents</a><a id="Contents-1"></a><a class="docs-heading-anchor-permalink" href="#Contents" title="Permalink"></a></h2><ul><li><a href="#Library">Library</a></li><ul><li><a href="#Contents">Contents</a></li><li><a href="#Public">Public</a></li><li><a href="#Private">Private</a></li><li><a href="#Index">Index</a></li></ul></ul><h2 id="Public"><a class="docs-heading-anchor" href="#Public">Public</a><a id="Public-1"></a><a class="docs-heading-anchor-permalink" href="#Public" title="Permalink"></a></h2><p>Documentation for <code>TestReports.jl</code>&#39;s public interface.</p><article class="docstring"><header><a class="docstring-binding" id="TestReports.test" href="#TestReports.test"><code>TestReports.test</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">TestReports.test(; kwargs...)
TestReports.test(pkg::Union{AbstractString, Vector{AbstractString}; kwargs...)</code></pre><p><strong>Keyword arguments:</strong></p><ul><li><code>coverage::Bool=false</code>: enable or disable generation of coverage statistics.</li><li><code>julia_args::Union{Cmd, Vector{String}}</code>: options to be passed to the test process.</li><li><code>test_args::Union{Cmd, Vector{String}}</code>: test arguments (<code>ARGS</code>) available in the test process.</li><li><code>logfilepath::AbstractString=pwd()</code>: file path where test reports are saved.</li><li><code>logfilename::Union{AbstractString, Vector{AbstractString}}</code>: name(s) of test report file(s).</li></ul><p>Generates a JUnit XML for the tests of package <code>pkg</code>, or for the current project (which thus needs to be a package) if no positional argument is given to <code>TestReports.test</code>. The test report is saved in the current working directory and called <code>testlog.xml</code> if both <code>logfilepath</code> and <code>logfilename</code> are not supplied. If <code>pkg</code> is of type <code>Vector{String}</code>, the report filenames are prepended with the package name, for example <code>Example_testlog.xml</code>.</p><p>If <code>logfilename</code> is supplied, it must match the type (and length, if a vector) of <code>pkg</code>.</p><p>The tests are run in the same way as <code>Pkg.test</code>.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="TestReports.recordproperty" href="#TestReports.recordproperty"><code>TestReports.recordproperty</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">recordproperty(name::String, value)</code></pre><p>Adds a property to a testset with <code>name</code> and <code>value</code> that will in turn be added to the <code>&lt;properties&gt;</code> node of the corresponding testsuite in the JUnit XML.</p><p>Multiple properties can be added to one testset, but if the same property is set on both parent and child testsets, the value in the parent testset takes precedence over that in the child.</p><p>The suggested use of this function is to place it inside a testset with unspecified type (see Examples). This will ensure that <code>Pkg.test</code> is unnaffected, but that the properties are added to the report when <code>TestReports.test</code> is used. This is because <code>TestReports</code> wraps package tests in a <code>ReportingTestSet</code>, and the function only adds a property when it is within a <code>ReportingTestSet</code>. </p><p>If a child testset is a <code>ReportingTestSet</code> but its parent isn&#39;t, the property should be in the report when <code>TestReport.test</code> is used, assuming that the parent testset type doesn&#39;t do anything to affect the reporting behaviour. However this is not tested functionality.</p><p><code>value</code> must be serializable by EzML, which gives quite a lot of freedom.</p><p><strong>Examples</strong></p><pre><code class="language-julia">using TestReports

# Default testset used, so function will not affect Pkg.test but will be used when
# generating JUnit XML.
@testset &quot;MyTestSet&quot; begin
    recordproperty(&quot;ID&quot;, 42)
    recordproperty(&quot;File&quot;, @__FILE__)
    recordproperty(&quot;Bool&quot;, true)
    @test 1==1
    @test 2==2
end</code></pre></div></section></article><div class="admonition is-warning"><header class="admonition-header">Missing docstring.</header><div class="admonition-body"><p>Missing docstring for <code>ReportingTestSet</code>. Check Documenter&#39;s build log for details.</p></div></div><article class="docstring"><header><a class="docstring-binding" id="TestReports.any_problems" href="#TestReports.any_problems"><code>TestReports.any_problems</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">any_problems(ts)</code></pre><p>Checks a testset to see if there were any problems (<code>Error</code>s or <code>Fail</code>s). Note that unlike the <code>DefaultTestSet</code>, the <code>ReportingTestSet</code> does not throw an exception on a failure. Thus to set the exit code from the runner code, we check it using <code>exit(any_problems(top_level_testset))</code>.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="TestReports.report" href="#TestReports.report"><code>TestReports.report</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">report(ts::AbstractTestSet)</code></pre><p>Will produce an <code>XMLDocument</code> that contains a report about the <code>TestSet</code>&#39;s results. This report will follow the JUnit XML schema.</p><p>In theory this works on many kinds of <code>TestSet</code>s, but it is primarily intended for use on <code>ReportingTestSet</code>s. To report correctly, the <code>TestSet</code> must have the following structure:</p><pre><code class="language-none">AbstractTestSet
  └─ AbstractTestSet
       └─ Result</code></pre><p>That is, the results of the top level <code>TestSet</code> must all be <code>AbstractTestSet</code>s, and the results of those <code>TestSet</code>s must all be <code>Results</code>.</p></div></section></article><h2 id="Private"><a class="docs-heading-anchor" href="#Private">Private</a><a id="Private-1"></a><a class="docs-heading-anchor-permalink" href="#Private" title="Permalink"></a></h2><p>Package internals documentation.</p><h3 id="Report-Generation"><a class="docs-heading-anchor" href="#Report-Generation">Report Generation</a><a id="Report-Generation-1"></a><a class="docs-heading-anchor-permalink" href="#Report-Generation" title="Permalink"></a></h3><article class="docstring"><header><a class="docstring-binding" id="TestReports.checkinstalled!" href="#TestReports.checkinstalled!"><code>TestReports.checkinstalled!</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">checkinstalled!(ctx::Union{Context, EnvCache}, pkgspec::Types.PackageSpec)</code></pre><p>Checks if the package is installed by using <code>ensure_resolved</code> from <code>Pkg/src/Types.jl</code>. This function fails if the package is not installed, but here we wrap it in a try-catch as we may want to test another package after the one that isn&#39;t installed.</p><p>For Julia versions V1.4 and later, the first arguments of the Pkg functions used is of type <code>Pkg.Types.Context</code>. For earlier versions, they are of type <code>Pkg.Types.EnvCache</code>.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="TestReports.gettestfilepath" href="#TestReports.gettestfilepath"><code>TestReports.gettestfilepath</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">gettestfilepath(ctx::Context, pkgspec::Types.PackageSpec)</code></pre><p>Gets the testfile path of the package. Code for each Julia version mirrors that found  in <code>Pkg\src\Operations.jl</code>.</p></div></section></article><h3 id="TestSets"><a class="docs-heading-anchor" href="#TestSets">TestSets</a><a id="TestSets-1"></a><a class="docs-heading-anchor-permalink" href="#TestSets" title="Permalink"></a></h3><article class="docstring"><header><a class="docstring-binding" id="TestReports._flatten_results!-Tuple{Test.AbstractTestSet}" href="#TestReports._flatten_results!-Tuple{Test.AbstractTestSet}"><code>TestReports._flatten_results!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">_flatten_results!(ts::AbstractTestSet)::Vector{&lt;:AbstractTestSet}</code></pre><p>Recursively flatten <code>ts</code> to a vector of <code>TestSet</code>s.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="TestReports._flatten_results!-Tuple{Test.Result}" href="#TestReports._flatten_results!-Tuple{Test.Result}"><code>TestReports._flatten_results!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">_flatten_results!(rs::Result)</code></pre><p>Return vector containing <code>rs</code> so that when iterated through, <code>rs</code> is added to the results vector.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="TestReports.add_to_ts_default!-Tuple{Test.DefaultTestSet,Test.Result}" href="#TestReports.add_to_ts_default!-Tuple{Test.DefaultTestSet,Test.Result}"><code>TestReports.add_to_ts_default!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">add_to_ts_default!(ts_default::DefaultTestSet, result::Result)
add_to_ts_default!(ts_default::DefaultTestSet, ts::AbstractTestSet)
add_to_ts_default!(ts_default::DefaultTestSet, ts::ReportingTestSet)</code></pre><p>Populate <code>ts_default</code> with the supplied variable. If the variable is a <code>Result</code> or an <code>AbstractTestSet</code> (but not a <code>ReportingTestSet</code>) then it is <code>record</code>ed. If it is a <code>ReportingTestSet</code> then a new <code>DefaultTestSet</code> with matching description is created, populated by recursively calling this function and then added to the results of <code>ts_default</code>.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="TestReports.flatten_results!-Tuple{Test.AbstractTestSet}" href="#TestReports.flatten_results!-Tuple{Test.AbstractTestSet}"><code>TestReports.flatten_results!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">flatten_results!(ts::AbstractTestSet)</code></pre><p>Returns a flat structure 3 deep, of <code>TestSet</code> -&gt; <code>TestSet</code> -&gt; <code>Result</code>. This is necessary for writing a report, as a JUnit XML does not allow one testsuite to be nested in another. The top level <code>TestSet</code> becomes the testsuites element, and the middle level <code>TestSet</code>s become individual testsuite elements, and the <code>Result</code>s become the testcase elements.</p><p>If <code>ts.results</code> contains any <code>Result</code>s, these are added into a new <code>TestSet</code> with the description &quot;Top level tests&quot;, which then replaces them in <code>ts.results</code>.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="TestReports.handle_top_level_results!-Tuple{Test.AbstractTestSet}" href="#TestReports.handle_top_level_results!-Tuple{Test.AbstractTestSet}"><code>TestReports.handle_top_level_results!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">handle_top_level_results!(ts::AbstractTestSet)</code></pre><p>If <code>ts.results</code> contains any <code>Result</code>s, these are removed from <code>ts.results</code> and added to a new <code>ReportingTestSet</code>, which in turn is added to <code>ts.results</code>. This leaves <code>ts.results</code> only containing <code>AbstractTestSet</code>s.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="TestReports.update_testset_properties!-Tuple{Test.AbstractTestSet,Test.AbstractTestSet}" href="#TestReports.update_testset_properties!-Tuple{Test.AbstractTestSet,Test.AbstractTestSet}"><code>TestReports.update_testset_properties!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">update_testset_properties!(childts::AbstractTestSet, ts::AbstractTestSet)
update_testset_properties!(childts::ReportingTestSet, ts::ReportingTestSet)</code></pre><p>Adds properties of <code>ts</code> to <code>childts</code>. If any properties being added already exist in <code>childts</code>, a warning is displayed and the value in <code>ts</code> is overwritten.</p><p>If <code>ts</code> and\or <code>childts</code> is not a <code>ReportingTestSet</code>, this is handled in the <code>AbstractTestSet</code> method:</p><ul><li>If <code>ts</code> is not a <code>ReportingTestSet</code>, it has no properties to add to <code>childts</code>   and therefore nothing happens.</li><li>If <code>childts</code> is not a <code>ReportingTestSet</code> and <code>ts</code> has properties, then a warning   is shown.</li></ul></div></section></article><h3 id="XML-Writing"><a class="docs-heading-anchor" href="#XML-Writing">XML Writing</a><a id="XML-Writing-1"></a><a class="docs-heading-anchor-permalink" href="#XML-Writing" title="Permalink"></a></h3><article class="docstring"><header><a class="docstring-binding" id="TestReports.add_testsuite_properties!-Tuple{Any,ReportingTestSet}" href="#TestReports.add_testsuite_properties!-Tuple{Any,ReportingTestSet}"><code>TestReports.add_testsuite_properties!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">add_testsuite_properties!(x_testsuite, ts::ReportingTestSet)</code></pre><p>Add all key value pairs in the <code>properties</code> field of a <code>ReportingTestSet</code> to the corresponding testsuite xml element.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="TestReports.error_xml-Tuple{Any,Any,Any}" href="#TestReports.error_xml-Tuple{Any,Any,Any}"><code>TestReports.error_xml</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">failure_xml(message, test_type, content)</code></pre><p>Create an error node (which will be the child of a testcase).</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="TestReports.failure_xml-Tuple{Any,Any,Any}" href="#TestReports.failure_xml-Tuple{Any,Any,Any}"><code>TestReports.failure_xml</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">failure_xml(message, test_type, content)</code></pre><p>Create a failure node (which will be the child of a testcase).</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="TestReports.get_error_info-Tuple{Test.Error}" href="#TestReports.get_error_info-Tuple{Test.Error}"><code>TestReports.get_error_info</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">get_error_info(v::Error)</code></pre><p>Return message and type of error for testcase attribute. Uses <code>test_type</code> field to determine what caused the original error.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="TestReports.get_failure_message-Tuple{Test.Fail}" href="#TestReports.get_failure_message-Tuple{Test.Fail}"><code>TestReports.get_failure_message</code></a> — <span class="docstring-category">Method</span></header><section><div><p>get<em>failure</em>message(v::Fail)</p><p>Return message for failed test testcase attribute. Uses <code>test_type</code> field to determine what caused the original failure.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="TestReports.set_attribute!-Tuple{Any,Any,Any}" href="#TestReports.set_attribute!-Tuple{Any,Any,Any}"><code>TestReports.set_attribute!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">set_attribute!(node, attr, val)</code></pre><p>Add the attritube with name <code>attr</code> and value <code>val</code> to <code>node</code>.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="TestReports.skip_xml-Tuple{}" href="#TestReports.skip_xml-Tuple{}"><code>TestReports.skip_xml</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">skip_xml()</code></pre><p>Create a skip node (which will be the child of a testcase).</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="TestReports.testcase_xml-Tuple{Any,Any,Any}" href="#TestReports.testcase_xml-Tuple{Any,Any,Any}"><code>TestReports.testcase_xml</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">testcase_xml(name, id, x_children)</code></pre><p>Create a testcase element of a JUnit XML.</p><p>This is the generic form (with name, id and children) that is used by other methods.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="TestReports.testcase_xml-Tuple{Test.Result,Any}" href="#TestReports.testcase_xml-Tuple{Test.Result,Any}"><code>TestReports.testcase_xml</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">testcase_xml(v::Result, childs)</code></pre><p>Create a testcase element of a JUnit XML for the result <code>v</code>.</p><p>The original expression of the test is used as the name, whilst the id is defaulted to <em>testcase</em>id_.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="TestReports.testsuite_xml-NTuple{6,Any}" href="#TestReports.testsuite_xml-NTuple{6,Any}"><code>TestReports.testsuite_xml</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">testsuite_xml(name, id, ntests, nfails, nerrors, x_children)</code></pre><p>Create a testsuite element of a JUnit XML.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="TestReports.testsuites_xml-NTuple{6,Any}" href="#TestReports.testsuites_xml-NTuple{6,Any}"><code>TestReports.testsuites_xml</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">testsuites_xml(name, id, ntests, nfails, nerrors, x_children)</code></pre><p>Create the testsuites element of a JUnit XML.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="TestReports.to_xml-Tuple{Test.AbstractTestSet}" href="#TestReports.to_xml-Tuple{Test.AbstractTestSet}"><code>TestReports.to_xml</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">to_xml(ts::AbstractTestSet)</code></pre><p>Create a testsuite node from an <code>AbstractTestSet</code>, by creating nodes for each result in <code>ts.results</code>. For creating a JUnit XML, all results must be <code>Result</code>s, that is they cannot be <code>AbstractTestSet</code>s, as the XML cannot have one testsuite nested inside another.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="TestReports.to_xml-Tuple{Test.Pass}" href="#TestReports.to_xml-Tuple{Test.Pass}"><code>TestReports.to_xml</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">to_xml(res::Pass)
to_xml(res::Fail)
to_xml(res::Broken)
to_xml(res::Error)</code></pre><p>Create a testcase node from the result and return it along with information on number of tests.</p></div></section></article><h2 id="Index"><a class="docs-heading-anchor" href="#Index">Index</a><a id="Index-1"></a><a class="docs-heading-anchor-permalink" href="#Index" title="Permalink"></a></h2><ul><li><a href="#TestReports._flatten_results!-Tuple{Test.Result}"><code>TestReports._flatten_results!</code></a></li><li><a href="#TestReports._flatten_results!-Tuple{Test.AbstractTestSet}"><code>TestReports._flatten_results!</code></a></li><li><a href="#TestReports.add_testsuite_properties!-Tuple{Any,ReportingTestSet}"><code>TestReports.add_testsuite_properties!</code></a></li><li><a href="#TestReports.add_to_ts_default!-Tuple{Test.DefaultTestSet,Test.Result}"><code>TestReports.add_to_ts_default!</code></a></li><li><a href="#TestReports.any_problems"><code>TestReports.any_problems</code></a></li><li><a href="#TestReports.checkinstalled!"><code>TestReports.checkinstalled!</code></a></li><li><a href="#TestReports.error_xml-Tuple{Any,Any,Any}"><code>TestReports.error_xml</code></a></li><li><a href="#TestReports.failure_xml-Tuple{Any,Any,Any}"><code>TestReports.failure_xml</code></a></li><li><a href="#TestReports.flatten_results!-Tuple{Test.AbstractTestSet}"><code>TestReports.flatten_results!</code></a></li><li><a href="#TestReports.get_error_info-Tuple{Test.Error}"><code>TestReports.get_error_info</code></a></li><li><a href="#TestReports.get_failure_message-Tuple{Test.Fail}"><code>TestReports.get_failure_message</code></a></li><li><a href="#TestReports.gettestfilepath"><code>TestReports.gettestfilepath</code></a></li><li><a href="#TestReports.handle_top_level_results!-Tuple{Test.AbstractTestSet}"><code>TestReports.handle_top_level_results!</code></a></li><li><a href="#TestReports.recordproperty"><code>TestReports.recordproperty</code></a></li><li><a href="#TestReports.report"><code>TestReports.report</code></a></li><li><a href="#TestReports.set_attribute!-Tuple{Any,Any,Any}"><code>TestReports.set_attribute!</code></a></li><li><a href="#TestReports.skip_xml-Tuple{}"><code>TestReports.skip_xml</code></a></li><li><a href="#TestReports.test"><code>TestReports.test</code></a></li><li><a href="#TestReports.testcase_xml-Tuple{Any,Any,Any}"><code>TestReports.testcase_xml</code></a></li><li><a href="#TestReports.testcase_xml-Tuple{Test.Result,Any}"><code>TestReports.testcase_xml</code></a></li><li><a href="#TestReports.testsuite_xml-NTuple{6,Any}"><code>TestReports.testsuite_xml</code></a></li><li><a href="#TestReports.testsuites_xml-NTuple{6,Any}"><code>TestReports.testsuites_xml</code></a></li><li><a href="#TestReports.to_xml-Tuple{Test.AbstractTestSet}"><code>TestReports.to_xml</code></a></li><li><a href="#TestReports.to_xml-Tuple{Test.Pass}"><code>TestReports.to_xml</code></a></li><li><a href="#TestReports.update_testset_properties!-Tuple{Test.AbstractTestSet,Test.AbstractTestSet}"><code>TestReports.update_testset_properties!</code></a></li></ul></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../manual/">« Manual</a><a class="docs-footer-nextpage" href="../contributing/">Contributing »</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> on <span class="colophon-date" title="Monday 19 October 2020 20:57">Monday 19 October 2020</span>. Using Julia version 1.5.2.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
